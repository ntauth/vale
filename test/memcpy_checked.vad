include{:from BASE} "arch/x64/decls.vad"
include{:from BASE} "arch/x64/decls64.vad"

include{:from BASE}{:verbatim} "arch/x64/leakage.i.dfy"
include{:from BASE}{:verbatim} "arch/x64/print.s.dfy"

#verbatim
import opened x64def_s_temp = x64_def_s
import opened x64vale_temp = x64_vale_i
import opened x64decls_temp = x64_decls_i
import opened x64decls64_temp = x64_decls64_i
import opened x64_print_s_temp = x64_print_s
import opened x64_const_time_i_temp = x64_const_time_i
#endverbatim

procedure {:timeLimitMultiplier 2}{:refined} Copy64(
    inline taint: taint,
    ghost src_id: heaplet_id,
    ghost dst_id: heaplet_id
)
    requires/ensures
        HasStackSlots(stack, 2);
        // rsi % 8 == 0;
        // rdi % 8 == 0;
        // rsi + 64 <= rdi || rdi + 64 <= rsi;
        // forall i:int {mem?[i]}{ValidSrcAddr(mem, src_id, i, 64, taint)} :: rsi <= i < rsi + 64 && i % 8 == 0 ==> ValidSrcAddr(mem, src_id, i, 64, taint);
        // forall i:int {mem?[i]}{ValidDstAddr(mem, dst_id, i, 64)} :: rdi <= i < rdi + 64 && i % 8 == 0 ==> ValidDstAddr(mem, dst_id, i, 64);
        ValidSrcAddrs(mem, src_id, rsi, 64, taint, 64);
        ValidDstAddrs(mem, dst_id, rdi, 64, 64);
        // src_id != dst_id;
    ensures
        // forall i :: 0 <= i < 64 && i % 8 == 0 ==> mem[dst_id].mem64[rdi + i] == mem[src_id].mem64[rsi + i];
    reads
        rsi; rdi;
    modifies
        stack;
        mem;
        rax; rbx; rcx; rdx;
        efl;
{
    Load64(rax, rsi, 0, taint, src_id);
    Load64(rbx, rsi, 8, taint, src_id);
    Load64(rcx, rsi, 16, taint, src_id);
    Load64(rdx, rsi, 24, taint, src_id);
    Store64(rdi, rax, 0, taint, dst_id);
    Store64(rdi, rbx, 8, taint, dst_id);
    Store64(rdi, rcx, 16, taint, dst_id);
    Store64(rdi, rdx, 24, taint, dst_id);
    // Uncomment to leak on the stack
    // Load64(rax, rsi, 0, taint, src_id);
    // StoreStack64(0, rax);
    Load64(rax, rsi, 32, taint, src_id);
    Load64(rbx, rsi, 40, taint, src_id);
    Load64(rcx, rsi, 48, taint, src_id);
    Load64(rdx, rsi, 56, taint, src_id);
    Store64(rdi, rax, 32, taint, dst_id);
    Store64(rdi, rbx, 40, taint, dst_id);
    Store64(rdi, rcx, 48, taint, dst_id);
    Store64(rdi, rdx, 56, taint, dst_id);
    // Scrub non-volatile regs to fix leak
    // @fix: XOR semantics do not reset the taint
    // Xor64(rax, rax);
    // Xor64(rbx, rbx);
    // Xor64(rcx, rcx);
    // Xor64(rdx, rdx);
    Mov64(rax, 0);
    Mov64(rbx, 0);
    Mov64(rcx, 0);
    Mov64(rdx, 0);
}

#verbatim

method Main()
    decreases *
{
    var stackSize := 0x10_0000; // 1 MiB
    var code := va_code_Copy64(Secret);
    var ts := TaintState(map i | 0 <= i < stackSize :: Public, map[X86Esi := Public, X86Edi := Public, X86Eax := Public, X86Ebx := Public, X86Ecx := Public, X86Edx := Public], map[], Public);
    var b := checkConstantTime("Copy64", code, ts);

    if (b == false) {
        print ("[!] Not constant time\n");
    } else {
        print("[+] Constant time verified successfully\n");
        
        var tsExpected := TaintState(map i | 0 <= i < stackSize :: Public, map[X86Esi := Public, X86Edi := Public, X86Eax := Public, X86Ebx := Public, X86Ecx := Public, X86Edx := Public], map[], Public);
        b := checkLeakage("Copy64", code, ts, tsExpected);

        if (b == false) {
            print ("[!] Leakage detected\n");
        } else {
            print("[+] No leakage detected\n");
            printHeader(GCC);
            printProc("Copy64", code, 0, 1, GCC);
            printFooter(GCC);
        }
    }
}

#endverbatim